package redbug.coPathfinding.whca;

import java.awt.Point;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.PriorityQueue;
import java.util.Properties;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;

import redbug.coPathfinding.planner.MyCanvas;
import redbug.coPathfinding.planner.MyMath;
import redbug.coPathfinding.prm.PRMplanar;


//use for the space-time hash table (in the paper, called time-space map)
class SpaceTimeNode{
	int nid;
	int t;
	
	public SpaceTimeNode(int nid, int t){
		this.nid = nid;
		this. t = t;
	}
	
	@Override
	//automatic generated by eclipse
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + nid;
		result = prime * result + t;
		return result;
	}

	@Override
	//automatic generated by eclipse
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		SpaceTimeNode other = (SpaceTimeNode) obj;
		if (nid != other.nid)
			return false;
		if (t != other.t)
			return false;
		return true;
	}
}


public class WHCAstar {
	PRMplanar prmPlanar = PRMplanar.getInstance();
	
	private final int INFINITE = 99999;
	
	PriorityQueue<ExpandedNode> open_RRAstar;					//Open List is a PriorityQueue
	Comparator<ExpandedNode> comparator;						//comparator for PriorityQueue
	HashSet<Integer> containNodeInOpen_RRAstar;					//記錄在open list裡有哪些node, 用來查詢用是否更新Open裡的node的cost
	HashMap<Integer, Float> closedTable;						/*
	 															 * "expandedNode.Id" map to "exapdnedNode.g"
																 * closedTable was used for collecting the cost of each expanded node 
	 															 * during RRA* search in order to provide the accurate heuristic 
	 															 * for A* search from initial to target.
	 															 */	
	
	ExpandedNode firstNode;										//the first node to be expanded when TSA*(d) start every time.
	
	static HashMap<Integer, HashSet<Integer>> reservationTable = new HashMap<Integer, HashSet<Integer>>();		//nodeId -> t frame set
	
	Point iNode, gNode;											// The initial and goal node
	
	static Logger logger = Logger.getLogger(WHCAstar.class);
	
	
	public WHCAstar(Point iNode, Point gNode){
		this.iNode = iNode;
		this.gNode = gNode;

		comparator = new Comparator<ExpandedNode>(){
			public int compare(ExpandedNode a, ExpandedNode b){
				float ac = a.g + a.h;
				float bc = b.g + b.h;
				return (ac < bc ? -1 : (ac == bc ? 0 : 1));  
			}};	
		
		open_RRAstar = new PriorityQueue<ExpandedNode>(1000, comparator);	
		containNodeInOpen_RRAstar = new HashSet<Integer>();
		
		/************************************************
		 * RRA* initialization
		 ************************************************/
		initializeRRAstar(iNode, gNode);
		firstNode = new ExpandedNode(MyMath.point2NodeId(iNode), iNode, 0, abstractDist(iNode, gNode), 0);
		
		
		/*********************************************
		 * log4j
		 *********************************************/
	    Properties logp = new Properties();
	    try {
	      logp.load(WHCAstar.class.getClassLoader()
	        .getResourceAsStream( "log4j.properties"));
	    } catch (IOException e) {
	      e.printStackTrace();
	    }
	    
	    PropertyConfigurator.configure(logp);
		logger.setLevel(Level.INFO); 
	    
	}
	
	public static void clearReservationTable(){						
		reservationTable.clear();
	}
	
	/*************************************
	 * Euclidean distance
	 *************************************/
	public float distance(Point p1, Point p2){
		return (float)(p1.distance(p2));
	}

	
	/**************************************************************************
	 * For the purpose of testing RRA* by display how many nodes are expanded. 
	 **************************************************************************/
	public ArrayList<Point> getRRAClosed() {
		ArrayList<Point> result = new ArrayList<Point>();
		for(Integer i: closedTable.keySet()){
			result.add(MyMath.nodeId2Point(i));
		}
		
		return result;
	}
	

	/**************************************************************************
	 * For the purpose of testing RRA* by display how many nodes are explored. 
	 **************************************************************************/
	public ArrayList<Point> getPRAOpen() {
		ArrayList<Point> result = new ArrayList<Point>();
		for(ExpandedNode p: open_RRAstar){
			result.add(p.position);
		}
		return result;
	}

	/**************************************************************************
	 * To insert an explored node into the open list of RRA* 
	 **************************************************************************/
	public void insertOpen_RRAstar(ExpandedNode node){
		open_RRAstar.add(node);
		containNodeInOpen_RRAstar.add(node.nodeId);
	}
	
	/**************************************************************************
	 * To pop an explored node from the open list of RRA* 
	 **************************************************************************/
	public ExpandedNode popOpen_RRAstar(){
		ExpandedNode bestNode;
		bestNode = open_RRAstar.poll();	
		containNodeInOpen_RRAstar.remove(bestNode.nodeId);
		closedTable.put(bestNode.nodeId, bestNode.g); 		
		return bestNode;
	}

	
	/**************************************************************************
	 * To query the reservation information of a node.  
	 **************************************************************************/
	private HashSet<Integer> getReservedRecord(int nodeId){
		if(!reservationTable.containsKey(nodeId)){		//the neighbor hasn't count in adjacent list.
			return new HashSet<Integer>();
		}else{								
			return reservationTable.get(nodeId);
		}	
	}
	
	/**************************************************************************
	 * RRA* initialization. 
	 **************************************************************************/
	public void initializeRRAstar(Point iNode, Point gNode){
		int gId = MyMath.point2NodeId(gNode);
		ExpandedNode goalNode = new ExpandedNode(gId, gNode, 0f, distance(iNode, gNode), 0);
		insertOpen_RRAstar(goalNode);
		closedTable = new HashMap<Integer, Float>();
		RRAstar(iNode);
	}
	
	
	/**********************************************************************
	 * Reverse Resumable A* (RRA*)
	 * The purpose of this function is to expand the target node so that
	 * we can get the heuristic of the target node which we need during TSA*. 
	 *  
	 * return true,  if search successfully
	 *        false, if search failed
	 *      
	 **********************************************************************/
	public boolean RRAstar(Point targetNode){

		ExpandedNode currentNode;							//The best node in this turn.
		HashSet<Integer> neighbors;

		//the variables of neighbor
		ExpandedNode neighbor;
		float nHistoryCost = 0;								
		float nHeuristic = 0;								
		int nId;											
		float nCost = 0;									
		Point nPosition;
		
		int tId = MyMath.point2NodeId(targetNode);

		Object tmpArray[];
		Integer nRSortedArray[];   //reversely sorted array of neighbors of currentNode.
		
		HashMap<Integer, HashSet<Integer>> adjacentList = prmPlanar.getAdjacentList();

					
		while(!open_RRAstar.isEmpty()){	
			currentNode = popOpen_RRAstar();
			
			logger.debug("RRA* - currentNode: " + currentNode.position);		
			
			if(currentNode.nodeId == tId){				
				return true;				//successfully finding the target;
			}
			
			neighbors = adjacentList.get(currentNode.nodeId);
			if(neighbors != null){
				
				tmpArray = neighbors.toArray();
				nRSortedArray = new Integer[tmpArray.length];
				
				for(int i=0; i < tmpArray.length; i++){
					nRSortedArray[i] = (Integer)tmpArray[i];
				}
				
				
				/*****************************************************************************************
				 * This is achieved by reversing the ordering of the successor function in RRA* to 
				 * ensure that ties are broken in the same direction(e.g. a left fork in the forward direction
				 * should become a right fork in the reverse direction).
				 * 
				 * We just modify a little bit in the compare function to achieve the reverse order of 
				 * the successor function compare with that in TSAStar.
				 *****************************************************************************************/
				Arrays.sort(nRSortedArray, new Comparator<Integer>(){
												public int compare(Integer a, Integer b){
													return (a < b ? -1 : (a == b ? 0 : 1));  
												}});
				for(int i=0; i < nRSortedArray.length; i++){
					nId = nRSortedArray[i];
					if(closedTable.containsKey(nId)){
						continue;
					}
					
					nPosition = MyMath.nodeId2Point(nId);
					nCost = distance(currentNode.position, nPosition);
					nHistoryCost = currentNode.g + nCost;
					nHeuristic = distance(nPosition, iNode);
									
					neighbor = new ExpandedNode(nId, nPosition, nHistoryCost, nHeuristic, 0);
					
					if(!containNodeInOpen_RRAstar.contains(nId)){
						logger.debug("RRA* - insertOpen: "+ nPosition);						
						insertOpen_RRAstar(neighbor);
					}else{
						/******************************************************************
						 *  if neighbor included in open and it gets less history cost, 
						 *  updating the neighbor in open.
						 ******************************************************************/
						tmpArray = open_RRAstar.toArray();
						for(int k=0; k<tmpArray.length; k++){
							if( ((ExpandedNode)tmpArray[k]).nodeId == nId){
								if(nHistoryCost < ((ExpandedNode)tmpArray[k]).g){
									if(!open_RRAstar.remove(tmpArray[k])){
										System.exit(1);
									}
									open_RRAstar.add(neighbor);
								}
								break;
							}
						}
					}
				}
			}		
		} 
		return false; 				//search failed;
	}
	
	
	/************************************************************************************************
	 * To get the true distance heuristic to the goal for Point n from the abstract map generated by RRA*.
	 * if the the true distance heuristic of point n doesn't exist, call the RRAstar.
	 ************************************************************************************************/
	float abstractDist(Point n, Point g){
		int nId = MyMath.point2NodeId(n);
		if(closedTable.containsKey(nId)){
			return closedTable.get(nId);
		}
		else{
			logger.debug("==================== Calling RRA* =====================");
			if(RRAstar(n)){
				return closedTable.get(nId);
			}
			
			return INFINITE;
		}
	}
	
	
	
	/****************************************************************
	 * Space-Time A* (STA*)
	 * The window size is equivalent to the available nodes which agent can expand in each window.
	 * if agent has already stay on the destination, return an empty result Path.
	 * else return partial path whether it's empty or not.  
	 * 
	 ****************************************************************/
	public ArrayList<Point> STAstar( int windowSize ){
		
		int gId = MyMath.point2NodeId(gNode);
		int iId = MyMath.point2NodeId(iNode);
		
		ArrayList<Point> partialPath = new ArrayList<Point>();
		
		if(firstNode.nodeId == gId){
			return partialPath;	
		}
		
		//Open List is a PriorityQueue
		PriorityQueue<ExpandedNode> open_STAstar = new PriorityQueue<ExpandedNode>(1000, comparator);
		
		//記錄在open list裡有哪些node, 用來查詢用是否更新Open裡的node的cost
		HashSet<SpaceTimeNode> containNodeInOpen_STAstar = new HashSet<SpaceTimeNode>(500);	   
				
		
		HashSet<Integer> neighbors, reservedRecord;
		
		//The best node in this turn.
		ExpandedNode candidateNode;							
		int cId;
		
		//the variables of neighbor
		ExpandedNode neighbor;
		float nHistoryCost = 0;
		float nHeuristic = 0;
		int nId;
		float nCost = 0;
		int nT;
		Point nPosition;
		
		int counter = 0;		

		Object tmpArray[];
		Integer nSortedArray[];   //sorted array of neighbors of currentNode. (different with that in RRAstar)
	
		
		HashMap<Integer, HashSet<Integer>> adjacentList = prmPlanar.getAdjacentList();
		
		
		/********************************************************************************
		 * Because the first node of the present window is the last node of the previous window, 
		 * there has already existed a record of the first node of the present window in the reservation table before TSA*.  
		 * Hence, we must remove the reserved information of the first node from the reservation table,
		 * so that the TSA* can go on for searching the new partial path in the present window.
		 ********************************************************************************/
		if(firstNode.nodeId != iId){
			reservationTable.get(firstNode.nodeId).remove(firstNode.t);
		}
		
		/*****************************************************************
		 *  insert first node into the open list of TSA* 
		 *****************************************************************/	
		open_STAstar.add(firstNode);
		containNodeInOpen_STAstar.add(new SpaceTimeNode(firstNode.nodeId, firstNode.t));
				

		while(!open_STAstar.isEmpty()){		
			candidateNode = open_STAstar.poll();	
			containNodeInOpen_STAstar.remove(new SpaceTimeNode(candidateNode.nodeId, candidateNode.t));	
					
			logger.debug("TSA* - currentNode: " + candidateNode.position);			
			
			cId = candidateNode.nodeId;
			
			/****************************************************************
			 *  if candidate cell at time is not available, 
			 *  don't care about it, just pop next candidate from open list.
			 ****************************************************************/
			reservedRecord = getReservedRecord(cId);
			if(reservedRecord.contains(candidateNode.t)){		//There is another agent in my way.
				continue;
			}
			
			counter++;						//To count the number of the nodes which been successfully expended in TSA* 	
			
			/********************************************************
			 * Once reaching goal or run out of window size, 
			 * it will return the search path immediately.
			 ********************************************************/
			if(counter >= windowSize || candidateNode.nodeId == gId){
				ExpandedNode tmpNode = candidateNode;
				
				while(tmpNode != null){
					/*********************************************************************
					 * After each agent's route is calculated, 
					 * the states along the route are marked into the reservation table.
					 *********************************************************************/
					reservedRecord = getReservedRecord(tmpNode.nodeId);
					reservedRecord.add(tmpNode.t);
					reservedRecord.add(tmpNode.t + 1);	//For solving the situation that two nearby agents head to head across through each other.
					reservationTable.put(tmpNode.nodeId, reservedRecord);	
					
					/***************************************************************************************
					 * The last node of the present window, the candidateNode here, 
					 * also need to reserved a record in the reservation table.
					 * However, it shouldn't been counted into the partial path in the present window, 
					 * because it will been counted into the partial path in the next window.
					 * The only exception is that candidateNode is equivalent to the goal node. 
					 * In this case, the candidateNode should been add into the partial path in the present window.
					 ***************************************************************************************/
					if(tmpNode != candidateNode || tmpNode.nodeId == gId ){
						partialPath.add(0, tmpNode.position);
					}	
					tmpNode = tmpNode.getParentNode();
				}

				firstNode = candidateNode;			//the first node of the next window is equivalent to the last node of the present window.
				firstNode.setParentNode(null);
			
				return partialPath;				//success;
			}
			
			
			neighbors = adjacentList.get(candidateNode.nodeId);
			neighbors.add(candidateNode.nodeId);				//for the purpose of the pause action.
			
			if(neighbors != null){				
				tmpArray = neighbors.toArray();
				nSortedArray = new Integer[tmpArray.length];
				
				for(int i=0; i < tmpArray.length; i++){
					nSortedArray[i] = (Integer)tmpArray[i];
				}
				
				
				/*****************************************************************************************
				 * compare function is a little bit different with that in RRAstar
				 *****************************************************************************************/
				Arrays.sort(nSortedArray, new Comparator<Integer>(){
												public int compare(Integer a, Integer b){
													return (a > b ? -1 : (a == b ? 0 : 1));  
												}});
				
				for(int k=0; k < nSortedArray.length; k++){
					nId = nSortedArray[k];
					
					logger.debug("STA* - expandedNode: " + MyMath.nodeId2Point(nId));										

					nPosition = MyMath.nodeId2Point(nId);
					nCost = distance(candidateNode.position, nPosition);
					nCost = nCost==0f? 0.5f: nCost; //the cost of waiting action
					nHistoryCost = candidateNode.g + nCost;
					nHeuristic = abstractDist(nPosition, gNode);
					nT = candidateNode.t + 1;
									
					neighbor = new ExpandedNode(nId, nPosition, nHistoryCost, nHeuristic, nT);
					neighbor.setParentNode(candidateNode);
					
					if(!containNodeInOpen_STAstar.contains(new SpaceTimeNode(nId, nT))){
						/*****************************************************************
						 *  insert initial node into the open list of TSA* 
						 *****************************************************************/
						open_STAstar.add(neighbor);
						containNodeInOpen_STAstar.add(new SpaceTimeNode(neighbor.nodeId, neighbor.t));
						logger.debug("STA* - InsertOpen: " + nPosition);						
					}
//					else{
//						/******************************************************************
//						 *  if neighbor included in open and it gets less history cost, 
//						 *  updating the neighbor in open.
//						 ******************************************************************/
//						tmpArray = open_TSAstar.toArray();
//						for(int i=0; i<tmpArray.length; i++){
//							tmpNode = (ExpandedNode)tmpArray[i]; 
//							if(tmpNode.nodeId == nId && tmpNode.t == nT ){
//								if(nHistoryCost < ((ExpandedNode)tmpArray[i]).g){
//									if(!open_TSAstar.remove(tmpArray[i])){
//										System.out.println("fuck you!");
//										System.exit(1);
//									}
//									open_TSAstar.add(neighbor); //doesn't need to update the containNodeInOpen.
//								}
//								break;
//							}
//						}// end of for loop
//					}
					
				}
			}
		}
		return partialPath; 				//search failed and return empty path.
	}	
}
